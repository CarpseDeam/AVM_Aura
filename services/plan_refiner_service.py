# services/plan_refiner_service.py
import logging
import re
from typing import List, Set, Tuple

logger = logging.getLogger(__name__)


class PlanRefinerService:
    """
    A deterministic service to clean and optimize the raw, human-readable plan
    generated by the Architect LLM before it's sent to the Technician.
    """

    def __init__(self):
        logger.info("PlanRefinerService initialized.")

    def _extract_and_remove_dependencies(self, text: str) -> Tuple[str, Set[str]]:
        """
        Finds a '### Dependencies' section, extracts the list,
        and removes the entire section from the text.
        """
        dependencies: Set[str] = set()
        # This regex finds the whole block from '### Dependencies' to the next heading or end of string
        dependency_block_pattern = re.compile(r"^\s*### Dependencies\s*\n(.*?)(?=\n\s*###|\Z)",
                                              re.DOTALL | re.MULTILINE)

        match = dependency_block_pattern.search(text)

        if match:
            # Extract the content of the block
            block_content = match.group(1)
            # Find all list items within the block
            found_deps = re.findall(r"^\s*-\s*([\w\-=.]+)", block_content, re.MULTILINE)
            for dep in found_deps:
                dependencies.add(dep.lower())

            # Remove the entire matched block from the original text
            text = dependency_block_pattern.sub('', text).strip()

        return text, dependencies

    def refine(self, architect_text_response: str) -> List[str]:
        """
        Takes the full, raw text response from the Architect, extracts and consolidates
        dependencies from the special section, and then parses the remaining
        text for the numbered plan steps.

        Args:
            architect_text_response: The full, raw string from the Architect.

        Returns:
            A new, clean list of steps with a single, consolidated dependency step.
        """
        if not architect_text_response:
            return []

        # 1. Extract dependencies and remove their section from the main text
        clean_text, dependencies = self._extract_and_remove_dependencies(architect_text_response)

        # 2. Parse the remaining text for the numbered plan steps
        plan_steps = re.findall(r'^\s*\d+[.)]\s*(.*)', clean_text, re.MULTILINE)
        refined_plan = [step.strip() for step in plan_steps if step.strip()]

        # 3. If dependencies were found, inject the consolidated step
        if dependencies:
            sorted_deps = sorted(list(dependencies))
            deps_str = " and ".join([f"'{dep}'" for dep in sorted_deps])
            consolidated_step = f"Create a requirements.txt file with all necessary dependencies: {deps_str}."

            # Insert the step after project creation, if it exists, otherwise at the start.
            insert_pos = 0
            if refined_plan and "create a new project" in refined_plan[0].lower():
                insert_pos = 1

            refined_plan.insert(insert_pos, consolidated_step)
            logger.info(f"Refined plan: Injected consolidated dependency step: {consolidated_step}")

        return refined_plan