# services/tool_runner_service.py
import inspect
import logging
import asyncio
from pathlib import Path
from typing import Dict, Optional, Any

from event_bus import EventBus
from foundry import FoundryManager, BlueprintInvocation
from core.managers.project_manager import ProjectManager
from services.mission_log_service import MissionLogService
from services.vector_context_service import VectorContextService
from core.llm_client import LLMClient
from events import ToolCallInitiated, ToolCallCompleted, RefreshFileTree

logger = logging.getLogger(__name__)


class ToolRunnerService:
    """
    Executes tool calls generated by AI agents, managing the entire lifecycle
    from parameter injection through execution and result reporting.
    """

    PATH_PARAM_KEYS = {'path', 'file_path', 'target_path', 'source_path', 'output_path'}

    def __init__(
            self,
            event_bus: EventBus,
            foundry_manager: FoundryManager,
            project_manager: ProjectManager,
            mission_log_service: MissionLogService,
            vector_context_service: VectorContextService,
            llm_client: LLMClient
    ):
        self.event_bus = event_bus
        self.foundry_manager = foundry_manager
        self.project_manager = project_manager
        self.mission_log_service = mission_log_service
        self.vector_context_service = vector_context_service
        self.llm_client = llm_client

    def log(self, level: str, message: str):
        self.event_bus.emit("log_message_received", "ToolRunnerService", level, message)

    def _get_service_map(self) -> Dict[str, Any]:
        """Returns mapping of parameter names to injected services."""
        return {
            'project_manager': self.project_manager,
            'mission_log_service': self.mission_log_service,
            'vector_context_service': self.vector_context_service,
            'llm_client': self.llm_client,
            'foundry_manager': self.foundry_manager,
            'event_bus': self.event_bus
        }

    async def run_tool_by_dict(self, tool_call_dict: dict) -> Any:
        """
        Executes a tool call from a dictionary specification.
        Enhanced with better error handling and result validation.
        """
        if not tool_call_dict or not isinstance(tool_call_dict, dict):
            error_msg = "Error: Invalid tool call - must be a non-empty dictionary."
            self.log("error", error_msg)
            return error_msg

        tool_name = tool_call_dict.get("tool_name")
        if not tool_name:
            error_msg = "Error: Tool call missing required 'tool_name' field."
            self.log("error", error_msg)
            return error_msg

        blueprint = self.foundry_manager.get_blueprint(tool_name)
        if not blueprint:
            error_msg = f"Error: Blueprint '{tool_name}' not found in Foundry."
            self.log("error", error_msg)
            return error_msg

        arguments = tool_call_dict.get('arguments', {})
        if not isinstance(arguments, dict):
            arguments = {}

        invocation = BlueprintInvocation(blueprint=blueprint, parameters=arguments)
        result = await self.run_tool(invocation)

        self.log("info", f"Tool '{tool_name}' execution completed with result: {result}")
        return result

    async def run_tool(self, invocation: BlueprintInvocation) -> Any:
        """
        Executes a single blueprint invocation with comprehensive error handling
        and proper status determination.
        """
        blueprint = invocation.blueprint
        action_id = blueprint.id

        action_function = self.foundry_manager.get_action(blueprint.action_function_name)
        if not action_function:
            error_msg = f"Error: Action function '{blueprint.action_function_name}' not found."
            self.log("error", error_msg)
            return error_msg

        execution_params = self._prepare_parameters(action_function, invocation.parameters)
        display_params = self._create_display_params(execution_params)

        self.log("info", f"Executing: {action_id} with params {display_params}")

        widget_id = id(invocation)
        self.event_bus.emit(
            "tool_call_initiated",
            ToolCallInitiated(widget_id, action_id, display_params)
        )
        await asyncio.sleep(0.1)

        result = None
        status = "FAILURE"

        try:
            if inspect.iscoroutinefunction(action_function):
                result = await action_function(**execution_params)
            else:
                result = action_function(**execution_params)

            # Enhanced status determination
            status = self._determine_result_status(result)

            if status == "SUCCESS":
                self.event_bus.emit("refresh_file_tree", RefreshFileTree())
                self.log("success", f"Tool '{action_id}' executed successfully.")
            else:
                self.log("warning", f"Tool '{action_id}' execution had issues: {result}")

            return result

        except Exception as e:
            logger.exception("An exception occurred while executing blueprint '%s'.", action_id)
            result = f"Error executing Blueprint '{action_id}': {str(e)}"
            status = "FAILURE"
            self.log("error", result)
            return result

        finally:
            self.event_bus.emit(
                "tool_call_completed",
                ToolCallCompleted(widget_id, status, str(result) if result is not None else "No result")
            )

    def _determine_result_status(self, result: Any) -> str:
        """
        Determines if a tool execution result represents success or failure.
        Returns "SUCCESS" or "FAILURE".
        """
        if result is None:
            return "FAILURE"

        if isinstance(result, str):
            result_lower = result.strip().lower()
            if result_lower.startswith("error") or result_lower.startswith("❌"):
                return "FAILURE"
            if "error:" in result_lower or "failed:" in result_lower:
                return "FAILURE"
            if result_lower.startswith("successfully") or "success" in result_lower:
                return "SUCCESS"
            # Most string results that don't explicitly indicate error are considered success
            return "SUCCESS"

        if isinstance(result, dict):
            status = result.get('status', '').lower()
            if status in ["failure", "error", "failed"]:
                return "FAILURE"
            if status in ["success", "successful", "completed"]:
                return "SUCCESS"
            # Check for error fields
            if result.get('error') or result.get('errors'):
                return "FAILURE"
            # Default to success for structured responses without explicit failure
            return "SUCCESS"

        if isinstance(result, bool):
            return "SUCCESS" if result else "FAILURE"

        if isinstance(result, (int, float)):
            return "SUCCESS"

        # For other types (lists, objects, etc.), assume success unless empty
        if hasattr(result, '__len__'):
            return "SUCCESS" if len(result) > 0 else "FAILURE"

        return "SUCCESS"

    def _prepare_parameters(self, action_function: callable, action_params: dict) -> dict:
        """
        Prepares parameters for EXECUTION.
        It resolves all file paths to ABSOLUTE paths to ensure sandbox safety.
        It injects necessary services.
        """
        execution_params = action_params.copy()
        base_path: Optional[Path] = self.project_manager.active_project_path
        sig = inspect.signature(action_function)
        service_map = self._get_service_map()

        # Resolve relative paths to absolute paths
        if base_path:
            for key in self.PATH_PARAM_KEYS:
                if key in sig.parameters and key in execution_params:
                    relative_path_str = execution_params[key]
                    if isinstance(relative_path_str, str) and relative_path_str:
                        path_obj = Path(relative_path_str)
                        if not path_obj.is_absolute():
                            resolved_path = (base_path / path_obj).resolve()
                            execution_params[key] = str(resolved_path)

        # Inject services based on function signature
        for param_name in sig.parameters:
            if param_name in service_map:
                if service_map[param_name] is not None:
                    execution_params[param_name] = service_map[param_name]
            elif param_name == 'project_context':
                execution_params['project_context'] = self.project_manager.active_project_context

        return execution_params

    def _create_display_params(self, execution_params: dict) -> dict:
        """
        Creates a copy of parameters for display purposes, making paths relative.
        This version avoids deepcopying un-copyable service objects.
        """
        display_params = {}
        service_keys = list(self._get_service_map().keys()) + ['project_context']

        # Copy non-service parameters
        for key, value in execution_params.items():
            if key not in service_keys:
                display_params[key] = value

        # Make absolute paths relative for display
        base_path = self.project_manager.active_project_path
        if base_path:
            for key in self.PATH_PARAM_KEYS:
                if key in display_params and isinstance(display_params[key], str):
                    try:
                        abs_path = Path(display_params[key])
                        if abs_path.is_absolute():
                            display_params[key] = str(abs_path.relative_to(base_path))
                    except (ValueError, OSError):
                        # Keep original if path conversion fails
                        pass

        return display_params